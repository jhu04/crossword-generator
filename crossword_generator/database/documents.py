from collections.abc import Collection
from dataclasses import dataclass, field
import datetime
from enum import Enum
from random import randrange

import generation.constants as const
from generation.clue_processor import ClueProcessor
from generation.grid import Grid, Cell, Direction


@dataclass(frozen=True)
class PuzzleMetadata:
    formatType: str | None
    publishType: str
    title: str
    printDate: str
    printDotw: int | None
    editor: str | None
    height: int
    width: int
    author: str


@dataclass(frozen=True)
class Clue:
    clueStart: int
    clueNum: int
    clueEnd: int
    value: str


@dataclass(frozen=True)
class Clues:
    A: Collection[Clue]
    D: Collection[Clue]


@dataclass(frozen=True)
class PuzzleData:
    clues: Clues
    layout: Collection[int]
    answers: Collection[str | None]


@dataclass()
class Crossword:
    puzzle_id: int | None
    promo_id: None
    version: int
    puzzle_meta: PuzzleMetadata
    print_date: str = field(init=False)
    enhanced_tier_date: datetime.date | None
    puzzle_data: PuzzleData

    def __post_init__(self):
        assert len(self.puzzle_data.layout) == self.puzzle_meta.width * \
            self.puzzle_meta.height
        assert len(self.puzzle_data.answers) == self.puzzle_meta.width * \
            self.puzzle_meta.height

        self.print_date = self.puzzle_meta.printDate


@dataclass()
class PublishType(Enum):
    DAILY: str = 'Daily'
    FREE: str = 'Free'
    FAKE: str = 'Fake'


@dataclass(frozen=True)
class CrosswordBuilder:
    grid: Grid
    clue_processor: ClueProcessor
    publish_type: PublishType

    def __post_init__(self):
        if self.publish_type is PublishType.DAILY:
            assert self.grid.n in const.DAILY_MINI_SIZES or \
                self.grid.n in const.DAILY_MAXI_SIZES

    def cell_to_index(self, cell: Cell):
        return self.grid.n * (cell.row - 1) + (cell.col - 1)

    def get_clues(self) -> Clues:
        a, d = [], []
        for entry in self.grid.entries:
            df = self.clue_processor.clues
            contents = df[df.answer == entry.get_contents()]
            value = contents.iloc[randrange(0, len(contents))]['clue']
            clue = Clue(
                clueStart=self.cell_to_index(entry.cells[0]),
                clueNum=entry.id,
                clueEnd=self.cell_to_index(entry.cells[-1]),
                value=value
            )
            if entry.direction is Direction.ACROSS:
                a.append(clue)
            else:
                d.append(clue)

        return Clues(A=a, D=d)

    def get_layout(self) -> list[int]:
        layout = []
        for r in self.grid.cell_range:
            for c in self.grid.cell_range:
                layout.append(0 if self.grid.cell(r, c).is_block() else 1)
        return layout

    def get_answers(self) -> list[str]:
        answers = []
        for r in self.grid.cell_range:
            for c in self.grid.cell_range:
                answers.append(self.grid.cell(r, c).label)
        return answers

    def build(self) -> Crossword:
        today = datetime.date.today().strftime('%Y-%m-%d')
        if self.publish_type is PublishType.DAILY:
            if self.grid.n in const.DAILY_MINI_SIZES:
                title = 'The Daily Mini'
            elif self.grid.n in const.DAILY_MAXI_SIZES:
                title = 'The Daily Maxi'
            else:
                raise Exception(
                    f'{self.grid.n} is invalid size for daily puzzles')
        elif self.publish_type is PublishType.FREE:
            title = 'Free Mode'
        else:
            title = f'Fake Puzzle, Size {self.grid.n}'

        return Crossword(
            puzzle_id=None,
            promo_id=None,
            version=1,
            puzzle_meta=PuzzleMetadata(
                formatType=None,
                publishType=self.publish_type.value,
                title=title,
                printDate=today,
                printDotw=None,
                editor=None,
                height=self.grid.n,
                width=self.grid.n,
                author='Autogenerated by Preston Fu and Jeffrey Hu',
            ),
            enhanced_tier_date=None,
            puzzle_data=PuzzleData(
                clues=self.get_clues(),
                layout=self.get_layout(),
                answers=self.get_answers(),
            ),
        )
