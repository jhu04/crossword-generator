from collections.abc import Collection
from dataclasses import dataclass, field
import datetime
from enum import Enum
from random import randrange
import re
from typing import ClassVar

from generation.clue_processor import ClueProcessor
from generation.grid import Grid, Cell, Direction


@dataclass(frozen=True)
class PuzzleMetadata:
    formatType: str | None
    publishType: str
    title: str
    printDate: str
    printDotw: int | None
    editor: str | None
    height: int
    width: int
    author: str


@dataclass(frozen=True)
class Clue:
    clueStart: int
    clueNum: int
    clueEnd: int
    value: str


@dataclass(frozen=True)
class Clues:
    A: Collection[Clue]
    D: Collection[Clue]


@dataclass(frozen=True)
class PuzzleData:
    clues: Clues
    layout: Collection[int]
    answers: Collection[str | None]


@dataclass()
class Crossword:
    puzzle_id: int | None
    promo_id: None
    version: int
    puzzle_meta: PuzzleMetadata
    print_date: str = field(init=False)
    enhanced_tier_date: datetime.date | None
    puzzle_data: PuzzleData

    def __post_init__(self):
        assert len(self.puzzle_data.layout) == self.puzzle_meta.width * self.puzzle_meta.height
        assert len(self.puzzle_data.answers) == self.puzzle_meta.width * self.puzzle_meta.height

        self.print_date = self.puzzle_meta.printDate


@dataclass()
class PublishType(Enum):
    DAILY: str = 'Daily'
    FREE: str = 'Free'
    FAKE: str = 'Fake'


@dataclass(frozen=True)
class CrosswordBuilder:
    INVALID_CLUE_CONTENT: ClassVar[re.Pattern] = re.compile(r'\d+-(across|down)', re.I)

    grid: Grid
    clue_processor: ClueProcessor
    publish_type: PublishType

    def __post_init__(self):
        if self.publish_type is PublishType.DAILY:
            assert self.grid.n == 5 or self.grid.n == 11

    def cell_to_index(self, cell: Cell):
        return self.grid.n * (cell.row - 1) + (cell.col - 1)

    def get_clues(self) -> Clues:
        a = []
        d = []

        for entry in self.grid.entries:
            df = self.clue_processor.clues
            contents = df[df.answer == entry.get_contents()]

            while (value := contents.iloc[randrange(0, len(contents))]['clue']) and self.INVALID_CLUE_CONTENT.search(value):
                pass

            clue = Clue(
                clueStart=self.cell_to_index(entry.cells[0]),
                clueNum=entry.id,
                clueEnd=self.cell_to_index(entry.cells[-1]),
                value=value
            )

            if entry.direction is Direction.ACROSS:
                a.append(clue)
            else:
                d.append(clue)
        return Clues(A=a, D=d)

    def get_layout(self) -> list[int]:
        layout = []
        for r in range(1, self.grid.n + 1):
            for c in range(1, self.grid.n + 1):
                layout.append(0 if self.grid.cell(r, c).is_wall() else 1)
        return layout

    def get_answers(self) -> list[str]:
        answers = []
        for r in range(1, self.grid.n + 1):
            for c in range(1, self.grid.n + 1):
                answers.append(self.grid.cell(r, c).label)
        return answers

    def build(self) -> Crossword:
        today = datetime.date.today().strftime('%Y-%m-%d')
        

        return Crossword(
            puzzle_id=None,
            promo_id=None,
            version=1,
            puzzle_meta=PuzzleMetadata(
                formatType=None,
                publishType=self.publish_type.value,
                title=f'The Daily {"Mini" if self.grid.n == 5 else "Maxi"}' if self.publish_type is PublishType.DAILY else 'Free Mode',
                printDate=today,
                printDotw=None,
                editor=None,
                height=self.grid.n,
                width=self.grid.n,
                author='Autogenerated by Preston Fu and Jeffrey Hu',
            ),
            enhanced_tier_date=None,
            puzzle_data=PuzzleData(
                clues=self.get_clues(),
                layout=self.get_layout(),
                answers=self.get_answers(),
            ),
        )
